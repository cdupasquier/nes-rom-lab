# cpu_manager.py
from py65.devices.mpu6502 import MPU
import streamlit as st
import numpy as np
from utils import disasm

def init_cpu(prg_data: bytes, prg_size: int, reset_vector: int):
    """
    Initialise et retourne un CPU MPU avec le PRG-ROM mapp√© √† 0x8000..0xFFFF.
    """
    cpu = MPU()

    try:
        if prg_size == 16 * 1024:
            cpu.memory[0x8000:0x8000 + prg_size] = prg_data
            cpu.memory[0xC000:0xC000 + prg_size] = prg_data
        else:
            length = min(prg_size, 0x8000)
            cpu.memory[0x8000:0x8000 + length] = prg_data[:length]
    except Exception:
        cpu.memory[0x8000:0x8000 + min(prg_size, 0x8000)] = prg_data[:min(prg_size, 0x8000)]

    cpu.pc = reset_vector
    return cpu


def run_steps(session_state: dict, n: int = 1):
    """
    Ex√©cute n instructions sur le CPU stock√© dans session_state["cpu"].
    Met √† jour session_state['trace'], 'steps', 'executed_addrs', 'halted'.
    """
    if "cpu" not in session_state:
        return

    cpu = session_state["cpu"]
    if "trace" not in session_state:
        session_state["trace"] = []
    if "executed_addrs" not in session_state:
        session_state["executed_addrs"] = set()
    if "steps" not in session_state:
        session_state["steps"] = 0
    if "halted" not in session_state:
        session_state["halted"] = False

    last_pc = cpu.pc
    for _ in range(n):
        if session_state["halted"]:
            break
        pc = cpu.pc
        opcode = cpu.memory[pc]
        try:
            cpu.step()
        except Exception as e:
            session_state["trace"].append(f"‚ö†Ô∏è Erreur ex√©cution: {e}")
            session_state["halted"] = True
            break

        session_state["trace"].append(f"${pc:04X}: OPC=${opcode:02X}  A={cpu.a:02X} X={cpu.x:02X} Y={cpu.y:02X} SP={cpu.sp:02X}")
        session_state["steps"] += 1

        session_state["executed_addrs"].add(last_pc)
        session_state["executed_addrs"].add(cpu.pc)
        last_pc = cpu.pc

        if opcode == 0x00:  # BRK
            session_state["trace"].append("üü• BRK rencontr√© ‚Äî arr√™t du CPU.")
            session_state["halted"] = True
            break

    # ensure PC added for minimap
    session_state["executed_addrs"].add(cpu.pc)

import streamlit as st
import numpy as np
from . import disasm


def show_cpu_interface(prg_data: bytes):
    """Interface p√©dagogique de d√©couverte du CPU 6502 et du d√©sassemblage NES."""

    st.subheader("‚öôÔ∏è Processeur 6502 ‚Äî C≈ìur de la NES")

    st.markdown("""
    ### üß† Les bases ‚Äî Comment pense le processeur 6502

    Le **MOS 6502** est un petit processeur 8 bits, le c≈ìur de la console NES.  
    On peut l‚Äôimaginer comme un chef d‚Äôorchestre minuscule : il lit le programme,  
    ex√©cute les instructions les unes apr√®s les autres et d√©place les donn√©es en m√©moire.

    ---

    #### ‚öôÔ∏è Architecture simplifi√©e

    | √âl√©ment | R√¥le dans le processeur | Exemple concret |
    |:--|:--|:--|
    | **8 bits** | Taille des donn√©es manipul√©es ‚Äî le processeur ne comprend que les nombres de 0 √† 255. | `LDA #$20` charge la valeur 32 (0x20) dans un registre. |
    | **Registre A (Accumulateur)** | C‚Äôest la ‚Äúmain droite‚Äù du CPU. Presque toutes les op√©rations passent par lui : addition, comparaison, transfert. | `LDA`, `ADC`, `STA` |
    | **Registres X et Y** | Petits registres d‚Äôindex utilis√©s pour parcourir la m√©moire ou d√©caler des positions. | `LDX #$05` puis `LDA $2000,X` |
    | **Registre P (Processor Status)** | Contient **des drapeaux** qui indiquent l‚Äô√©tat du CPU : Z√©ro (Z), N√©gatif (N), Retenue (Carry), etc. | Apr√®s `LDA #$00`, le flag Z est activ√©. |
    | **PC (Program Counter)** | L‚Äôadresse m√©moire de la **prochaine instruction** √† ex√©cuter. Il avance automatiquement. | Si `PC = $8000`, la prochaine lecture sera √† `$8001`. |
    | **SP (Stack Pointer)** | Pointeur de pile : une petite zone de sauvegarde temporaire pour les sous-programmes et interruptions. | Lors d‚Äôun `JSR`, le CPU pousse l‚Äôadresse de retour sur la pile. |

    ---

    #### üí° Ce qu‚Äôil faut retenir

    - Le 6502 ne fait qu‚Äô**une seule chose √† la fois** (8 bits par 8 bits).  
    - Il lit le code, ex√©cute, met √† jour ses registres et recommence.  
    - La **m√©moire** est son terrain de jeu : tout ce qu‚Äôil fait, il le lit ou l‚Äô√©crit dedans.

    > üß© Une ROM NES n‚Äôest rien d‚Äôautre qu‚Äôun grand cahier d‚Äôinstructions binaires  
    > que ce petit processeur lit, interpr√®te et transforme en jeu vivant √† l‚Äô√©cran.
    """)

    # --- Tabs p√©dagogiques ---
    tab1, tab2 = st.tabs(["üìú D√©sassemblage interactif", "üîç Explications p√©dagogiques"])

    # ------------------------------------------------------------------
    # Onglet 1 : D√©sassemblage interactif
    # ------------------------------------------------------------------
    with tab1:
        st.markdown("### üìú D√©sassemblage interactif du code PRG-ROM")

        st.caption("""
        üí° Le d√©sassemblage consiste √† **traduire le binaire machine**
        en instructions lisibles (`LDA`, `STA`, `JSR`, etc.).
        """)

        # === Interface utilisateur ===
        start_addr = st.number_input(
            "Adresse de d√©part (hex):",
            min_value=0x0000, max_value=len(prg_data),
            value=0x0000, step=0x0010
        )
        count = st.slider("Nombre d‚Äôinstructions √† afficher :", 16, 128, 32)

        # --- Simulation m√©moire CPU ---
        class DummyCPU:
            def __init__(self, data):
                import numpy as np
                self.memory = np.frombuffer(data, dtype=np.uint8)
                self.instruction_size = {}

        cpu = DummyCPU(prg_data)

        # --- D√©sassemblage ---
        disasm_text = disasm.disassemble_full(cpu, start_addr, count=count)
        current_pc = start_addr
        html = disasm.colorize_disasm(disasm_text, current_pc)

        # === Rendu HTML isol√© ===
        with st.container():
            st.components.v1.html(html, height=500, scrolling=True)

        # === L√©gende p√©dagogique ===
        st.markdown("""
        <div style="
            margin-top:8px;
            padding:10px 14px;
            background-color:#1a1a1a;
            border-left:4px solid #444;
            border-radius:6px;
            color:#ccc;
            font-family:'JetBrains Mono', monospace;
            font-size:13px;
            line-height:1.5em;
        ">
        üß© Les <strong>opcodes color√©s</strong> indiquent la nature des instructions :<br>
        <span style="color:#00d084;">LDA</span> = chargement ‚Ä¢ 
        <span style="color:#ffb14f;">STA</span> = stockage ‚Ä¢ 
        <span style="color:#4fa3ff;">JSR/JMP</span> = saut ‚Ä¢ 
        <span style="color:#ff4f4f;">BRK/RTS</span> = fin / retour ‚Ä¢ 
        <span style="color:#00ccff;">BNE/BEQ/BCC</span> = branchements conditionnels
        </div>
        """, unsafe_allow_html=True)

    # ------------------------------------------------------------------
    # Onglet 2 : Explications p√©dagogiques
    # ------------------------------------------------------------------
    with tab2:
        st.markdown("### üîç Anatomie d‚Äôune instruction 6502")

        st.markdown("""
        Chaque instruction du processeur suit un sch√©ma simple :

        | √âl√©ment | Description | Exemple |
        |----------|--------------|----------|
        | **Opcode** | Code machine (1 octet) indiquant l'op√©ration | `LDA` |
        | **Mode d‚Äôadressage** | Fa√ßon dont l‚Äôinstruction lit la m√©moire | `#imm`, `$addr`, `(addr,X)` |
        | **Op√©rande** | La donn√©e ou adresse concern√©e | `#$20`, `$0600` |

        ### üßÆ Exemple :
        ```
        $8000: LDA #$20
        ```
        > Charge la valeur **$20** (32 en d√©cimal) dans l‚Äôaccumulateur `A`.

        ### üìä Types d‚Äôinstructions
        - **Transfert** (`LDA`, `STA`, `LDX`, `LDY`)
        - **Arithm√©tique** (`ADC`, `SBC`, `INC`, `DEC`)
        - **Logique** (`AND`, `ORA`, `EOR`)
        - **Sauts / branchements** (`JMP`, `JSR`, `BNE`, `BEQ`, `RTS`)
        - **Contr√¥le / drapeaux** (`CLC`, `SEC`, `SEI`, `CLI`, `NOP`)
        """)

        st.info("""
        üß† Le d√©sassembleur convertit donc une suite d‚Äôoctets en texte compr√©hensible.  
        En analysant les motifs (`JSR`, `LDA`, `STA`...), on peut reconstruire  
        le comportement du jeu original.
        """)
        
        
class SimpleCPU:
    """Simulation p√©dagogique ultra simplifi√©e du processeur MOS 6502."""
    def __init__(self, data: bytes):
        self.memory = np.frombuffer(data, dtype=np.uint8)
        self.pc = 0x0000
        self.a = 0
        self.x = 0
        self.y = 0
        self.sp = 0xFF
        self.p = 0b00100000  # Flag par d√©faut (bit 5 toujours √† 1)
        self.last_instr = ""

    def step(self):
        """Ex√©cute une instruction fictive (simulation p√©dagogique, non compl√®te)."""
        opcode = int(self.memory[self.pc])
        self.last_instr = disasm.disassemble_full(self, self.pc, 1)
        self.pc = (self.pc + 1) & 0xFFFF  # incr√©mente le PC
        self.a = (self.a + opcode) & 0xFF  # petite op√©ration bidon
        return self.last_instr

    def dump_registers(self):
        """Retourne un dictionnaire des registres actuels."""
        return {
            "PC": f"${self.pc:04X}",
            "A": f"${self.a:02X}",
            "X": f"${self.x:02X}",
            "Y": f"${self.y:02X}",
            "SP": f"${self.sp:02X}",
            "P (flags)": f"{self.p:08b}"
        }

# --------------------------------------------------------------
# INTERFACE STREAMLIT
# --------------------------------------------------------------

def show_cpu_step_interface(prg_data: bytes):
    """Interface interactive : CPU 6502 simul√© pas √† pas."""
    st.header("üßÆ Simulation CPU Step-by-Step (MOS 6502)")

    if "cpu" not in st.session_state:
        st.session_state["cpu"] = SimpleCPU(prg_data)

    cpu = st.session_state["cpu"]

    col1, col2 = st.columns([1, 1.5])
    with col1:
        st.subheader("üìä Registres actuels")
        st.json(cpu.dump_registers())

        if st.button("‚ñ∂Ô∏è Ex√©cuter une instruction"):
            last = cpu.step()
            st.session_state["last_instr"] = last
            st.toast("Instruction ex√©cut√©e !", icon="‚öôÔ∏è")

        if st.button("‚èπÔ∏è R√©initialiser CPU"):
            st.session_state["cpu"] = SimpleCPU(prg_data)
            st.session_state["last_instr"] = disasm.disassemble_full(st.session_state["cpu"], 0, 8)
            st.success("CPU remis √† z√©ro.")

    with col2:
        st.subheader("üìú D√©sassemblage")
        disasm_text = st.session_state.get("last_instr", disasm.disassemble_full(cpu, 0, 8))
        html = disasm.colorize_disasm(disasm_text, cpu.pc)
        st.markdown(html, unsafe_allow_html=True)

    st.caption("""
    üí° Cette simulation n‚Äôex√©cute pas le code r√©el,  
    mais reproduit le comportement du CPU pour t‚Äôaider √† visualiser le **cycle d‚Äôex√©cution** :
    lecture ‚Üí d√©codage ‚Üí ex√©cution ‚Üí incr√©ment du compteur de programme.  

    üß† **Astuce p√©dagogique :**
    - Premier clic sur ‚èπÔ∏è ‚Üí *reset partiel* (seuls les registres sont r√©initialis√©s)  
    - Second clic cons√©cutif ‚Üí *reset complet* (CPU et m√©moire reviennent √† $0000)
    """)